<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ELSIE CORP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">

  <style>
    :root{
      --px: 12;            /* snake tile size */
      --trail-steps: 520;  /* long tail so it reads like a frame */
      --band: 18vh;        /* spacing under fixed top overlay area */
      --dice: 76px;        /* dice size */
    }

    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: 'Cormorant Garamond', serif;
      overflow-x: hidden;
      scroll-behavior: smooth;
      overflow-anchor: none;
    }

    body { padding-top: var(--band); }

    /* Background slideshow (brighter) */
    .background-img {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-height: 70%;
      max-width: 70%;
      opacity: 0.40;
      pointer-events: none;
      z-index: 0;
      filter: contrast(120%) grayscale(60%) brightness(1.05);
      transition: opacity 180ms linear;
    }
    .black-flicker {
      position: fixed;
      inset: 0;
      background: #000;
      opacity: 0;
      transition: opacity 120ms linear;
      z-index: 6;
      pointer-events: none;
    }

    /* Snake layer (on top of content) */
    #snake-canvas{
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 50;         /* above everything except overlays */
      pointer-events: none;
      opacity: 1;
    }

    /* PLANNED ECONOMY label (hidden after ENTER/scroll) */
    .switcher {
      position: fixed;
      top: calc(var(--band) + 0.6rem);
      left: 50%;
      transform: translateX(-50%);
      font-family: Helvetica, Arial, sans-serif;
      font-weight: bold;
      font-size: 2.2rem;
      z-index: 4;
      display: flex; gap: 1rem;
      text-align: left;
      transition: opacity .25s ease;
    }
    .switcher.is-hidden { opacity: 0; pointer-events: none; }
    .planned-word { display: flex; flex-direction: column; align-items: flex-start; line-height: 1.1; }
    .anti-word { visibility: hidden; font-size: 3.2rem; opacity: 0; color: white; transition: opacity .3s, color .3s; }
    .anti-word.visible-white { visibility: visible; opacity: 1; color: white; }
    .anti-word.visible-red   { visibility: visible; opacity: 1; color: red; }

    /* Dice (two) — spacing + reliable 3D view */
    .dice {
      position: fixed;
      top: calc(var(--band) + 2.5rem);
      left: 7vw;
      width: var(--dice);
      height: var(--dice);
      perspective: 900px;
      perspective-origin: 50% 50%;
      z-index: 7;
      filter: drop-shadow(0 10px 20px rgba(0,0,0,.45)) drop-shadow(0 0 18px rgba(255,255,255,.18));
    }
    .dice2 { top: calc(var(--band) + 13.5rem); left: 10vw; }

    .dice .gimbal{
      width:100%; height:100%;
      transform-style: preserve-3d;
      transform-origin: 50% 50%;
      transform: rotateX(-10deg) rotateY(24deg) rotateZ(0deg);
      animation: wobble3d 6s ease-in-out infinite;
      will-change: transform;
    }
    @keyframes wobble3d{
      0%   { transform: rotateX(-10deg) rotateY(24deg) rotateZ(0deg); }
      50%  { transform: rotateX(-6deg)  rotateY(28deg) rotateZ(0deg); }
      100% { transform: rotateX(-10deg) rotateY(24deg) rotateZ(0deg); }
    }

    .dice, .dice .cube, .dice .face { transform-style: preserve-3d; }
    .dice .cube{
      position: relative; width: 100%; height: 100%;
      transition: transform 900ms cubic-bezier(.2,.8,.2,1);
      will-change: transform;
      transform: translateZ(0);
      cursor: pointer;
    }
    .dice .face{
      position: absolute; inset: 0;
      display: grid; grid-template: repeat(3,1fr) / repeat(3,1fr); place-items: center;
      background:
        radial-gradient(120% 120% at 30% 25%, rgba(255,255,255,.95), rgba(230,230,230,.9) 60%, rgba(210,210,210,.85) 100%);
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.08);
      box-shadow:
        inset 0 0 30px rgba(255,255,255,0.35),
        inset 0 0 8px rgba(0,0,0,0.15);
      backface-visibility: hidden;
    }
    .dice .pip{
      width: calc(var(--dice) * 0.16);
      height: calc(var(--dice) * 0.16);
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #000 0 45%, #333 46% 100%);
      box-shadow: 0 1px 0 rgba(255,255,255,.3), inset 0 1px 2px rgba(255,255,255,.25);
    }
    .dice .f1 { transform: translateZ(calc(var(--dice)/2)); }
    .dice .f2 { transform: rotateY(180deg) translateZ(calc(var(--dice)/2)); }
    .dice .f3 { transform: rotateY(90deg) translateZ(calc(var(--dice)/2)); }
    .dice .f4 { transform: rotateY(-90deg) translateZ(calc(var(--dice)/2)); }
    .dice .f5 { transform: rotateX(90deg) translateZ(calc(var(--dice)/2)); }
    .dice .f6 { transform: rotateX(-90deg) translateZ(calc(var(--dice)/2)); }

    /* Red overlay for doubles */
    .combo-overlay{
      position: fixed; inset: 0;
      background: #c40000;
      display: flex; align-items: center; justify-content: center;
      opacity: 0; transition: opacity .08s ease;
      z-index: 9999; pointer-events: none;
    }
    .combo-overlay.show{ opacity: 1; }
    .combo-overlay .big{
      font-family: Helvetica, Arial, sans-serif;
      font-weight: 900;
      font-size: clamp(6rem, 22vw, 28rem);
      color: #fff;
      letter-spacing: .08em;
      text-shadow: 0 0 24px rgba(255,255,255,.35);
    }

    /* Right stats panel */
    .stats{
      position: fixed;
      top: calc(var(--band) + 0.6rem);
      right: 7vw;
      text-align: right;
      z-index: 7;
      font-family: Helvetica, Arial, sans-serif;
      user-select: none;
    }
    .stats .perfumes{
      font-size: 0.95rem;
      letter-spacing: .18em;
      opacity: .9;
      font-weight: 700;
    }
    .stats .basket{
      margin-top: .4rem;
      font-size: 1.05rem;      /* a bit bigger per your request */
      letter-spacing: .18em;
      font-weight: 800;
      opacity: .95;
    }
    .stats .countdown{
      margin-top: .9rem;
      font-size: clamp(1.8rem, 4.2vw, 2.6rem); /* slightly smaller digits */
      font-weight: 900;
      letter-spacing: .15em;
      text-shadow: 0 0 14px rgba(255,255,255,.25), 0 0 24px rgba(255,255,255,.15);
      transition: transform 120ms ease;
    }
    .flash-red { color: #ff3b3b !important; text-shadow: 0 0 16px rgba(255,0,0,.5), 0 0 28px rgba(255,0,0,.3) !important; }
    .tiny-bounce { animation: tinyBounce .22s ease; }
    @keyframes tinyBounce {
      0% { transform: translateY(0); }
      40%{ transform: translateY(-2px); }
      100%{ transform: translateY(0); }
    }

    /* Hero + content */
    .hero { min-height: calc(100vh - var(--band)); display: grid; place-items: center; position: relative; z-index: 3; }
    .hero-inner { display: grid; place-items: center; }
    .text-flicker { font-family: 'Cinzel', serif; font-size: 5rem; text-align: center; animation: flicker 1s infinite; text-shadow: 0 0 10px white, 0 0 20px white; }
    @keyframes flicker { 0%,19%,21%,23%,25%,54%,56%,100%{opacity:1} 20%,24%,55%{opacity:.4} }
    #enter-btn { margin-top: 2rem; font: inherit; font-size: 1.2rem; background: none; color: #fff; border: 1px solid #fff; padding: .5rem 1.5rem; cursor: pointer; }
    #enter-btn:hover { background: #fff; color: #000; }

    .content { font-size: 1.7rem; min-height: 100vh; display: flex; justify-content: center; align-items: center; z-index: 2; position: relative; opacity: 0; transform: translateY(50px); transition: all 1.2s ease; padding: 0 10vw; text-align: left; background: #000; }
    .content.visible { opacity: 1; transform: translateY(0); }
    .text-block { max-width: 640px; }
    .text-block p { margin: 0 0 1rem 0; line-height: 1.5; }

    /* “JOIN” phantom button */
    .join-badge{
      margin-top: 1.6rem;
      display: inline-block;
      padding: .4rem 1.2rem;
      border: 1px solid #fff;
      font-family: 'Cinzel', serif;
      letter-spacing: .06em;
      opacity: 0;
      transform: translateY(6px);
      pointer-events: none;
      transition: opacity .2s ease, transform .2s ease;
    }
    .join-badge.show{
      opacity: 1;
      transform: translateY(0);
    }

    @media (max-width: 1024px) { .dice { left: 4vw; transform: scale(.9); } .dice2{ left: 7vw; } .stats{ right: 4vw; } }
    @media (max-width: 820px)  { .dice { display: none; } }
  </style>
</head>
<body>
  <!-- Background slideshow -->
  <img src="images.jpeg" alt="Background" class="background-img" id="bg-img">
  <div class="black-flicker" id="black-fx"></div>

  <!-- Snake layer -->
  <canvas id="snake-canvas"></canvas>

  <!-- DICE (two) with gimbals -->
  <div class="dice dice1">
    <div class="gimbal">
      <div class="cube" id="cube1">
        <div class="face f1"><span class="pip" style="grid-area:2/2;"></span></div>
        <div class="face f2"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f3"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f4"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f5"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f6"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/1;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/3;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      </div>
    </div>
  </div>

  <div class="dice dice2">
    <div class="gimbal">
      <div class="cube" id="cube2">
        <div class="face f1"><span class="pip" style="grid-area:2/2;"></span></div>
        <div class="face f2"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f3"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f4"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f5"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f6"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/1;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/3;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      </div>
    </div>
  </div>

  <!-- Right stats -->
  <div class="stats" id="stats">
    <div class="perfumes">PERFUMES</div>
    <div class="basket">IN YOUR BASKET: <span id="basket-count">0</span></div>
    <div class="countdown" id="countdown">00:00:00</div>
  </div>

  <!-- Red combo overlay -->
  <div class="combo-overlay" id="combo-overlay">
    <div class="big" id="combo-text"></div>
  </div>

  <!-- Label -->
  <div class="switcher" id="switcher">
    <span class="anti-word" id="anti-text">ANTI-</span>
    <div class="planned-word">
      <span class="line">PLANNED</span>
      <span class="line">ECONOMY</span>
    </div>
  </div>

  <!-- Hero -->
  <section class="hero">
    <div class="hero-inner">
      <div class="text-flicker" id="title">ELSIE CORP.</div>
      <button id="enter-btn">ENTER</button>
    </div>
  </section>

  <!-- Content -->
  <section class="content" id="reveal">
    <div class="text-block">
      <p><strong>ELSIE CORP</strong> is a perfume salon.</p>
      <p>We work with artists, theorists, funders, and institutions to shape forces, not products.</p>
      <p>Our primary goal is consensual abductive teamwork. Here, we are teaching a course on hyperadaptive identities.</p>

      <!-- “JOIN” phantom button -->
      <div class="join-badge" id="join-badge">JOIN</div>
    </div>
  </section>

  <script>
    /* Start at top */
    try { if ('scrollRestoration' in history) history.scrollRestoration = 'manual'; } catch(e){}
    window.addEventListener('load', () => window.scrollTo(0, 0));

    /* UI: ENTER + reveal */
    const enterBtn  = document.getElementById('enter-btn');
    const title     = document.getElementById('title');
    const reveal    = document.getElementById('reveal');
    const antiText  = document.getElementById('anti-text');
    const switcher  = document.getElementById('switcher');

    enterBtn.addEventListener('click', () => {
      title.style.animation = 'none';
      title.style.opacity = '1';
      enterBtn.style.display = 'none';
      switcher.classList.add('is-hidden');
      window.scrollTo({ top: reveal.offsetTop, behavior: 'smooth' });
    });

    let contentVisible = false;
    window.addEventListener('scroll', () => {
      const rect = reveal.getBoundingClientRect();
      if (rect.top < window.innerHeight) {
        reveal.classList.add('visible');
        switcher.classList.add('is-hidden');
        contentVisible = true;
      }
    });

    function complexFlickerAnti() {
      antiText.className = 'anti-word visible-white';
      setTimeout(() => {
        antiText.className = 'anti-word';
        setTimeout(() => {
          antiText.className = 'anti-word visible-red';
          setTimeout(() => {
            antiText.className = 'anti-word';
            setTimeout(() => {
              antiText.className = 'anti-word visible-white';
              setTimeout(() => { antiText.className = 'anti-word'; }, 200);
            }, 200);
          }, 120);
        }, 120);
      }, 120);
    }
    (function loopAntiFlicker() {
      const interval = Math.floor(Math.random() * 10000) + 5000;
      setTimeout(() => { complexFlickerAnti(); loopAntiFlicker(); }, interval);
    })();

    /* Slideshow with black flicker (4s) */
    const BG = document.getElementById('bg-img');
    const FX = document.getElementById('black-fx');

    const IMAGES = [
      'images.jpeg',
      '01.png','02.png','02.jpg','03.png','03.jpg',
      '04.jpg','05.jpg','06.jpg','07.jpg','08.jpg',
      '09.jpg','010.jpg','011.jpg','012.jpg','013.jpg'
    ];
    IMAGES.forEach(src => { const i = new Image(); i.src = src; });

    const SHOW_MS = 4000, FLICK_MS = 120;
    let idx = 1;

    /* ===== DICE + COUNTERS ===== */
    const cube1 = document.getElementById('cube1');
    const cube2 = document.getElementById('cube2');
    const POSES = [
      'rotateX(0deg) rotateY(0deg)',       // 1
      'rotateX(0deg) rotateY(180deg)',     // 2
      'rotateX(0deg) rotateY(-90deg)',     // 3
      'rotateX(0deg) rotateY(90deg)',      // 4
      'rotateX(-90deg) rotateY(0deg)',     // 5
      'rotateX(90deg) rotateY(0deg)'       // 6
    ];
    let faces = [0, 0];
    function setFace(cube, idx){ cube.style.transform = POSES[idx]; }
    function rollDie(i, cube){
      let n; do { n = (Math.random() * 6) | 0; } while (n === faces[i]);
      faces[i] = n; setFace(cube, n);
    }
    setFace(cube1, faces[0]); setFace(cube2, faces[1]);

    // basket / countdown UI
    const basketEl = document.getElementById('basket-count');
    const countdownEl = document.getElementById('countdown');
    const overlay = document.getElementById('combo-overlay');
    const comboText = document.getElementById('combo-text');
    let basket = 0;

    function flashOverlay(val){
      comboText.textContent = `${val}   ${val}`;
      overlay.classList.add('show');
      setTimeout(() => overlay.classList.remove('show'), 2000);
    }

    function flickerBasket(){
      basketEl.classList.add('flash-red');
      setTimeout(() => basketEl.classList.remove('flash-red'), 1000);
    }

    // random countdown target, then tick every second
    let cdTarget = new Date(Date.now() + 6*60*60*1000); // default 6h
    function setRandomCountdown(){
      const h = Math.floor(Math.random()*23); // 0..22
      const m = Math.floor(Math.random()*59);
      const s = Math.floor(Math.random()*59);
      const now = new Date();
      cdTarget = new Date(now.getTime() + ((h*3600 + m*60 + s) * 1000));

      // red flash for one second on new sequence
      countdownEl.classList.add('flash-red');
      setTimeout(() => countdownEl.classList.remove('flash-red'), 1000);
    }
    function tickCountdown(){
      const now = new Date();
      let diff = Math.max(0, Math.floor((cdTarget - now)/1000));
      const h = String(Math.floor(diff/3600)).padStart(2,'0');
      diff %= 3600;
      const m = String(Math.floor(diff/60)).padStart(2,'0');
      const s = String(diff%60).padStart(2,'0');
      countdownEl.textContent = `${h}:${m}:${s}`;
      countdownEl.classList.remove('tiny-bounce');
      // reflow to restart animation
      void countdownEl.offsetWidth;
      countdownEl.classList.add('tiny-bounce');
    }
    setInterval(tickCountdown, 1000);
    setRandomCountdown();

    // “JOIN” badge logic (randomly on dice shuffles when text is visible)
    const joinBadge = document.getElementById('join-badge');
    let joinWait = 1 + Math.floor(Math.random()*3); // 1..3
    function maybeShowJoin(){
      if (!contentVisible) return;
      joinWait--;
      if (joinWait <= 0){
        joinBadge.classList.add('show');
        setTimeout(() => joinBadge.classList.remove('show'), 1000);
        joinWait = 1 + Math.floor(Math.random()*3);
      }
    }

    // doubles detection + updates
    function afterDiceRolled(){
      if (faces[0] === faces[1]) {
        const val = faces[0] + 1;
        basket += 1;
        basketEl.textContent = basket;
        flickerBasket();
        flashOverlay(val);
        setRandomCountdown();
      }
      maybeShowJoin();
    }

    function rollBoth(){
      rollDie(0, cube1);
      rollDie(1, cube2);
      afterDiceRolled();
    }

    // Slideshow step every 4s — also roll dice in sync
    setInterval(() => {
      FX.style.opacity = '1';
      setTimeout(() => {
        BG.src = IMAGES[idx % IMAGES.length];
        idx++;
        rollBoth();                 // tie dice to the image change
        FX.style.opacity = '0';
      }, FLICK_MS);
    }, SHOW_MS);

    // Also allow clicking dice to roll immediately (and trigger snake gravitation)
    document.querySelectorAll('.cube').forEach(c => c.addEventListener('click', (e) => {
      e.stopPropagation();
      rollBoth();
      mode = 'grav';
      gravStrength = 0;
    }));

    /* ===================== SNAKE ===================== */
    const cvs = document.getElementById('snake-canvas');
    const ctx = cvs.getContext('2d');

    function resizeCanvas() {
      cvs.width  = window.innerWidth;
      cvs.height = window.innerHeight;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      computeFrame();
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const TILE  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--px'), 10);
    const TAIL  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--trail-steps'), 10);

    const MARGIN_FRAME = TILE * 2;

    let frame = { left: 80, top: 80, right: window.innerWidth-80, bottom: window.innerHeight-80 };
    function snap(v){ return Math.round(v / TILE) * TILE; }

    // Centered square around the slideshow — robust and always visible
    function computeFrame(){
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const s  = Math.round(0.70 * Math.min(vw, vh)); // 70% of the smaller viewport side
      const L0 = Math.round((vw - s) / 2);
      const T0 = Math.round((vh - s) / 2);
      frame.left   = snap(L0 - MARGIN_FRAME);
      frame.top    = snap(T0 - MARGIN_FRAME);
      frame.right  = snap(L0 + s + MARGIN_FRAME);
      frame.bottom = snap(T0 + s + MARGIN_FRAME);

      if (mode === 'rect') {
        head.x = frame.left;
        head.y = frame.top;
        dir = { x: TILE, y: 0 };
        rectEdge = 0;
      }
    }

    // snake state
    let head = { x: frame.left, y: frame.top };
    let dir  = { x: TILE, y: 0 };
    let trail = [];
    let lastStep = 0;

    // modes: 'rect' (perimeter) -> 'grav' (mouse gravitation)
    let mode = 'rect';
    let rectEdge = 0;                      // 0 top, 1 right, 2 bottom, 3 left
    const RECT_STEP_MS = 60;               // rectangle speed
    const GRAV_STEP_MS = 78;               // gravitate speed
    let gravStrength = 0;                  // grows after click
    let target = { x: window.innerWidth/2, y: window.innerHeight/2 };
    window.addEventListener('mousemove', (e) => { target.x = e.clientX; target.y = e.clientY; }, { passive: true });

    function step(now){
      requestAnimationFrame(step);
      const ms = (mode === 'rect') ? RECT_STEP_MS : GRAV_STEP_MS;
      if (now - lastStep < ms) return;
      lastStep = now;

      if (mode === 'rect') {
        let nx = head.x + dir.x;
        let ny = head.y + dir.y;

        if (rectEdge === 0 && nx >= frame.right)      { nx = frame.right;  dir = {x:0, y:TILE};   rectEdge = 1; }
        else if (rectEdge === 1 && ny >= frame.bottom){ ny = frame.bottom; dir = {x:-TILE, y:0}; rectEdge = 2; }
        else if (rectEdge === 2 && nx <= frame.left)  { nx = frame.left;   dir = {x:0, y:-TILE};  rectEdge = 3; }
        else if (rectEdge === 3 && ny <= frame.top)   { ny = frame.top;    dir = {x:TILE, y:0};   rectEdge = 0; }

        head = { x: nx, y: ny };

      } else {
        // GRAVITATE toward mouse in Manhattan steps
        gravStrength = Math.min(1, gravStrength + 0.06);
        const dx = target.x - head.x, dy = target.y - head.y;
        const preferX = Math.abs(dx) > Math.abs(dy) * (1 - 0.4*gravStrength);
        if (preferX && Math.abs(dx) > TILE/2)      dir = { x: Math.sign(dx)*TILE, y: 0 };
        else if (Math.abs(dy) > TILE/2)            dir = { x: 0, y: Math.sign(dy)*TILE };
        else                                       dir = { x: 0, y: 0 };

        head = {
          x: Math.max(TILE/2, Math.min(window.innerWidth  - TILE/2, head.x + dir.x)),
          y: Math.max(TILE/2, Math.min(window.innerHeight - TILE/2, head.y + dir.y))
        };
      }

      // trail buffer
      trail.unshift({ x: head.x, y: head.y });
      if (trail.length > TAIL) trail.pop();

      // draw
      ctx.clearRect(0, 0, cvs.width, cvs.height);

      // glow
      ctx.shadowColor = 'rgba(255,255,255,1)';
      ctx.shadowBlur = 26;

      // head
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(head.x, head.y, TILE * 0.85, 0, Math.PI * 2);
      ctx.fill();

      // body squares with fade (grid-snapped)
      for (let i = 1; i < trail.length; i++) {
        const t = i / trail.length;
        const alpha = Math.max(0, 1 - t * 1.05);
        if (alpha <= 0) continue;

        ctx.globalAlpha = alpha;

        const gx = Math.round(trail[i].x / TILE) * TILE;
        const gy = Math.round(trail[i].y / TILE) * TILE;

        ctx.fillStyle = '#fff';
        ctx.fillRect(gx - TILE/2, gy - TILE/2, TILE, TILE);

        // subtle inner pixel
        ctx.globalAlpha = alpha * 0.35;
        const p = TILE / 4;
        ctx.fillRect(gx - TILE/2 + p, gy - TILE/2 + p, TILE - 2*p, TILE - 2*p);
      }

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    // Seed a visible tail
    function primeTrail(len = 24){
      trail.length = 0;
      for (let i = 0; i < len; i++){
        trail.unshift({ x: frame.left - i*TILE, y: frame.top });
      }
    }

    requestAnimationFrame(step);
    computeFrame();
    primeTrail();
  </script>
</body>
</html>
