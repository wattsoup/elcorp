<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ELSIE CORP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">

  <style>
    :root{
      --px: 10;            /* snake tile size */
      --trail-steps: 360;  /* long tail */
      --band: 22vh;        /* spacing under the fixed top overlay area */
      --dice: 76px;        /* dice size */
    }

    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: 'Cormorant Garamond', serif;
      overflow-x: hidden;
      scroll-behavior: smooth;
      overflow-anchor: none;
    }

    /* Push content below the top overlay area */
    body { padding-top: var(--band); }

    /* Background slideshow image (brighter) */
    .background-img {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-height: 70%;
      max-width: 70%;
      opacity: 0.40;
      pointer-events: none;
      z-index: 0;
      filter: contrast(120%) grayscale(60%) brightness(1.05);
      transition: opacity 180ms linear;
    }

    /* Black flicker between images */
    .black-flicker {
      position: fixed;
      inset: 0;
      background: #000;
      opacity: 0;
      transition: opacity 120ms linear;
      z-index: 6;
      pointer-events: none;
    }

    /* Mouse-tied snake: full-viewport canvas */
    #snake-canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 5;
      pointer-events: none;
      transition: opacity .6s ease;  /* for fade out/in on click */
    }

    /* PLANNED / ECONOMY (below the top overlay) */
    .switcher {
      position: fixed;
      top: calc(var(--band) + 1.2rem);
      left: 50%;
      transform: translateX(-50%);
      font-family: Helvetica, Arial, sans-serif;
      font-weight: bold;
      font-size: 2.5rem;
      z-index: 4;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      text-align: left;
      transition: opacity .25s ease;   /* fade-out */
    }
    .switcher.is-hidden { opacity: 0; pointer-events: none; }

    .anti-word { visibility: hidden; font-size: 4.5rem; opacity: 0; color: white; transition: opacity .3s, color .3s; }
    .anti-word.visible-white { visibility: visible; opacity: 1; color: white; }
    .anti-word.visible-red   { visibility: visible; opacity: 1; color: red; }
    .planned-word { display: flex; flex-direction: column; align-items: flex-start; line-height: 1.1; text-align: left; }

   .dice {
  position: fixed;
  top: calc(var(--band) + 3rem); /* first die */
  left: 8vw;
  width: var(--dice);
  height: var(--dice);
  perspective: 600px;
  z-index: 7;
  filter: drop-shadow(0 10px 20px rgba(0,0,0,.45)) drop-shadow(0 0 18px rgba(255,255,255,.25));
}
.dice2 { top: calc(var(--band) + 9.5rem); } /* second die lower */

.dice .cube {
  position: relative; width: 100%; height: 100%;
  transform-style: preserve-3d;
  transition: transform 900ms cubic-bezier(.2,.8,.2,1);
}
.dice .face {
  position: absolute; inset: 0;
  display: grid; grid-template: repeat(3,1fr) / repeat(3,1fr); place-items: center;
  background: linear-gradient(145deg, #ffffff, #e7e7e7);
  border-radius: 12px;
  box-shadow: inset 0 0 30px rgba(255,255,255,0.35), inset 0 0 6px rgba(0,0,0,0.15);
}
/* BLACK pips */
.dice .pip{
  width: calc(var(--dice) * 0.16);
  height: calc(var(--dice) * 0.16);
  border-radius: 50%;
  background: radial-gradient(circle at 35% 35%, #000 0 45%, #333 46% 100%);
  box-shadow: 0 1px 0 rgba(255,255,255,.3), inset 0 1px 2px rgba(255,255,255,.25);
}
/* faces in 3D */
.dice .f1 { transform: translateZ(calc(var(--dice)/2)); }
.dice .f2 { transform: rotateY(180deg) translateZ(calc(var(--dice)/2)); }
.dice .f3 { transform: rotateY(90deg) translateZ(calc(var(--dice)/2)); }
.dice .f4 { transform: rotateY(-90deg) translateZ(calc(var(--dice)/2)); }
.dice .f5 { transform: rotateX(90deg) translateZ(calc(var(--dice)/2)); }
.dice .f6 { transform: rotateX(-90deg) translateZ(calc(var(--dice)/2)); }

    /* Red overlay for doubles */
.combo-overlay{
  position: fixed; inset: 0;
  background: #c40000;
  display: flex; align-items: center; justify-content: center;
  opacity: 0; transition: opacity .15s ease;
  z-index: 9999; pointer-events: none;
}
.combo-overlay.show{ opacity: 1; }
.combo-overlay .big{
  font-family: Helvetica, Arial, sans-serif;
  font-weight: 900;
  font-size: clamp(6rem, 22vw, 28rem);
  color: #fff;
  letter-spacing: .08em;
  text-shadow: 0 0 24px rgba(255,255,255,.35);
}



    /* Hero centered perfectly */
    .hero {
      min-height: calc(100vh - var(--band));
      display: grid;
      place-items: center;
      position: relative;
      z-index: 3;
    }
    .hero-inner { display: grid; place-items: center; }

    .text-flicker {
      font-family: 'Cinzel', serif;
      font-size: 5rem;
      text-align: center;
      animation: flicker 1s infinite;
      text-shadow: 0 0 10px white, 0 0 20px white;
      transition: opacity 0.1s ease-out;
    }
    @keyframes flicker {
      0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% { opacity: 1; }
      20%, 24%, 55% { opacity: 0.4; }
    }

    #enter-btn {
      margin-top: 2rem;
      font-family: inherit;
      font-size: 1.2rem;
      background: none;
      color: white;
      border: 1px solid white;
      padding: 0.5rem 1.5rem;
      cursor: pointer;
      z-index: 3;
      transition: all 0.2s ease;
    }
    #enter-btn:hover { background: white; color: black; }

    .content {
      font-size: 1.7rem;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2;
      position: relative;
      opacity: 0;
      transform: translateY(50px);
      transition: all 1.2s ease;
      padding: 0 10vw;
      text-align: left;
      background: black;
    }
    .content.visible { opacity: 1; transform: translateY(0); }

    .text-block { max-width: 640px; }
    .text-block p { margin: 0 0 1rem 0; line-height: 1.5; }

    @media (max-width: 1024px) {
      .dice { left: 4vw; transform: scale(.9); }
    }
    @media (max-width: 820px) {
      .dice { display: none; } /* hide dice on small screens */
    }
  </style>
</head>
<body>
  <!-- Background slideshow -->
  <img src="images.jpeg" alt="Background" class="background-img" id="bg-img">
  <div class="black-flicker" id="black-fx"></div>

  <!-- Snake layer -->
  <canvas id="snake-canvas"></canvas>

  <!-- Dice -->
  <!-- DICE (two of them) -->
<div class="dice dice1">
  <div class="cube" id="cube1">
    <div class="face f1"><span class="pip" style="grid-area:2/2;"></span></div>
    <div class="face f2"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    <div class="face f3"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    <div class="face f4"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    <div class="face f5"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    <div class="face f6"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/1;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/3;"></span><span class="pip" style="grid-area:3/3;"></span></div>
  </div>
</div>

<div class="dice dice2">
  <div class="cube" id="cube2">
    <div class="face f1"><span class="pip" style="grid-area:2/2;"></span></div>
    <div class="face f2"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    <div class="face f3"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    <div class="face f4"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    <div class="face f5"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    <div class="face f6"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/1;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/3;"></span><span class="pip" style="grid-area:3/3;"></span></div>
  </div>
</div>

<!-- Red combo overlay (keep near top of body is fine) -->
<div class="combo-overlay" id="combo-overlay">
  <div class="big" id="combo-text"></div>
</div>


  <!-- Label (fades out after ENTER) -->
  <div class="switcher" id="switcher">
    <span class="anti-word" id="anti-text">ANTI-</span>
    <div class="planned-word">
      <span class="line">PLANNED</span>
      <span class="line">ECONOMY</span>
    </div>
  </div>

  <!-- Hero -->
  <section class="hero">
    <div class="hero-inner">
      <div class="text-flicker" id="title">ELSIE CORP.</div>
      <button id="enter-btn">ENTER</button>
    </div>
  </section>

  <!-- Content -->
  <section class="content" id="reveal">
    <div class="text-block">
      <p><strong>ELSIE CORP</strong> is a perfume salon.</p>
      <p>We work with artists, theorists, funders, and institutions to shape forces, not products.</p>
      <p>Our primary goal is consensual abductive teamwork. Here, we are teaching a course on hyperadaptive identities.</p>
    </div>
  </section>

  <script>
    /* Start at top */
    try { if ('scrollRestoration' in history) history.scrollRestoration = 'manual'; } catch(e){}
    window.addEventListener('load', () => window.scrollTo(0, 0));

    /* --- UI: ENTER + reveal --- */
    const enterBtn  = document.getElementById('enter-btn');
    const title     = document.getElementById('title');
    const reveal    = document.getElementById('reveal');
    const antiText  = document.getElementById('anti-text');
    const switcher  = document.getElementById('switcher');

    enterBtn.addEventListener('click', () => {
      title.style.animation = 'none';
      title.style.opacity = '1';
      enterBtn.style.display = 'none';
      switcher.classList.add('is-hidden');            // hide PLANNED/ECONOMY
      window.scrollTo({ top: reveal.offsetTop, behavior: 'smooth' });
    });

    window.addEventListener('scroll', () => {
      const rect = reveal.getBoundingClientRect();
      if (rect.top < window.innerHeight) {
        reveal.classList.add('visible');
        switcher.classList.add('is-hidden');
      }
    });

    function complexFlickerAnti() {
      antiText.className = 'anti-word visible-white';
      setTimeout(() => {
        antiText.className = 'anti-word';
        setTimeout(() => {
          antiText.className = 'anti-word visible-red';
          setTimeout(() => {
            antiText.className = 'anti-word';
            setTimeout(() => {
              antiText.className = 'anti-word visible-white';
              setTimeout(() => { antiText.className = 'anti-word'; }, 200);
            }, 200);
          }, 120);
        }, 120);
      }, 120);
    }
    (function loopAntiFlicker() {
      const interval = Math.floor(Math.random() * 10000) + 5000;
      setTimeout(() => { complexFlickerAnti(); loopAntiFlicker(); }, interval);
    })();

    /* --- Slideshow with black flicker (4s) --- */
    const BG = document.getElementById('bg-img');
    const FX = document.getElementById('black-fx');

    const IMAGES = [
      'images.jpeg',
      '01.png','02.png','02.jpg','03.png','03.jpg',
      '04.jpg','05.jpg','06.jpg','07.jpg','08.jpg',
      '09.jpg','010.jpg','011.jpg','012.jpg','013.jpg'
    ];

    const SHOW_MS = 4000;
    const FLICK_MS = 120;

    IMAGES.forEach(src => { const i = new Image(); i.src = src; });

    let idx = 1;
    setInterval(() => {
      FX.style.opacity = '1';
      setTimeout(() => {
        BG.src = IMAGES[idx % IMAGES.length];
        idx++;
        FX.style.opacity = '0';
      }, FLICK_MS);
    }, SHOW_MS);

    /* --- TWO DICE: roll every 8s; flash red on doubles --- */
const cube1 = document.getElementById('cube1');
const cube2 = document.getElementById('cube2');
const cubes = [cube1, cube2];

// Pose order corresponds to face 1..6
const POSES = [
  'rotateX(0deg) rotateY(0deg)',       // 1
  'rotateX(0deg) rotateY(180deg)',     // 2
  'rotateX(0deg) rotateY(-90deg)',     // 3
  'rotateX(0deg) rotateY(90deg)',      // 4
  'rotateX(-90deg) rotateY(0deg)',     // 5
  'rotateX(90deg) rotateY(0deg)'       // 6
];

let faces = [0,0]; // store as indices 0..5 (= 1..6)

function rollDie(i){
  let n;
  do { n = Math.floor(Math.random()*6); } while (n === faces[i]);
  faces[i] = n;
  cubes[i].style.transform = POSES[n];
}

function checkComboAndFlash(){
  if (faces[0] === faces[1]) {
    const overlay = document.getElementById('combo-overlay');
    const text = document.getElementById('combo-text');
    const val = faces[0] + 1; // convert 0..5 -> 1..6
    text.textContent = `${val}   ${val}`;
    overlay.classList.add('show');
    setTimeout(() => overlay.classList.remove('show'), 2000);
  }
}

// initial pose
rollDie(0); rollDie(1);

// roll both every 8s (slightly staggered so they feel independent)
setInterval(() => {
  rollDie(0);
  setTimeout(() => { rollDie(1); checkComboAndFlash(); }, 350);
}, 8000);


    /* --- MOUSE-TIED SNAKE --- */
    const cvs = document.getElementById('snake-canvas');
    const ctx = cvs.getContext('2d');

    // scale for crispness
    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      cvs.width  = Math.floor(window.innerWidth  * dpr);
      cvs.height = Math.floor(window.innerHeight * dpr);
      cvs.style.width  = window.innerWidth + 'px';
      cvs.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const TILE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--px'), 10);
    const TRAIL_STEPS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--trail-steps'), 10);

    let head = { x: TILE*2, y: TILE*2 };
    let dir  = { x: TILE, y: 0 };
    let trail = [];
    let lastStep = 0;
    const STEP_MS = 38; // lower = faster steps

    let target = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let axisFlip = false; // alternate axis preference → more right-angle feel
    window.addEventListener('mousemove', (e) => {
      target.x = e.clientX;
      target.y = e.clientY;
    }, { passive: true });

    // click to hide for ~10s, then fade back (faint → full)
    let hideTimer = null, fadeTimer = null, snakePaused = false;
    document.addEventListener('click', () => {
      if (snakePaused) return;
      cvs.style.opacity = '0';
      snakePaused = true;
      clearTimeout(hideTimer); clearTimeout(fadeTimer);
      hideTimer = setTimeout(() => {
        cvs.style.opacity = '0.18';              // faint re-appearance
        fadeTimer = setTimeout(() => {
          cvs.style.opacity = '1';               // then ramp to full
          snakePaused = false;
        }, 2400);
      }, 10000);                                  // 10 seconds hidden
    });

    function step(now) {
      requestAnimationFrame(step);
      if (now - lastStep < STEP_MS) return;
      lastStep = now;

      // choose Manhattan step toward the mouse (Snake vibe)
      const dx = target.x - head.x, dy = target.y - head.y;
      if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
        // do nothing if already there
      } else {
        let moveXFirst = Math.abs(dx) > Math.abs(dy);
        if (axisFlip) moveXFirst = !moveXFirst;
        if (moveXFirst && Math.abs(dx) >= 1) {
          dir = { x: Math.sign(dx) * TILE, y: 0 };
        } else if (Math.abs(dy) >= 1) {
          dir = { x: 0, y: Math.sign(dy) * TILE };
        } else {
          // fallback
          dir = { x: Math.sign(dx) * TILE, y: 0 };
        }
        axisFlip = !axisFlip;

        head = { x: Math.max(TILE/2, Math.min(window.innerWidth - TILE/2, head.x + dir.x)),
                 y: Math.max(TILE/2, Math.min(window.innerHeight - TILE/2, head.y + dir.y)) };
      }

      // trail buffer
      trail.unshift({ x: head.x, y: head.y });
      if (trail.length > TRAIL_STEPS) trail.pop();

      // draw
      ctx.clearRect(0, 0, cvs.width, cvs.height);

      // glow
      ctx.shadowColor = 'rgba(255,255,255,1)';
      ctx.shadowBlur = 20;

      // head (rounded)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(head.x, head.y, TILE * 0.8, 0, Math.PI * 2);
      ctx.fill();

      // body squares with fade
      for (let i = 1; i < trail.length; i++) {
        const t = i / trail.length;
        const alpha = Math.max(0, 1 - t * 1.05);
        if (alpha <= 0) continue;

        ctx.globalAlpha = alpha;

        // snap to grid for that retro feel
        const gx = Math.round(trail[i].x / TILE) * TILE;
        const gy = Math.round(trail[i].y / TILE) * TILE;

        ctx.fillStyle = '#fff';
        ctx.fillRect(gx - TILE/2, gy - TILE/2, TILE, TILE);

        // subtle inner pixel
        ctx.globalAlpha = alpha * 0.35;
        const p = TILE / 4;
        ctx.fillRect(gx - TILE/2 + p, gy - TILE/2 + p, TILE - 2*p, TILE - 2*p);
      }

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }
    requestAnimationFrame(step);
  </script>
</body>
</html>
