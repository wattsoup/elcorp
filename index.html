<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ELSIE CORP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">

  <style>
    :root{
      --px: 10;            /* snake tile size */
      --trail-steps: 360;  /* long tail */
      --band: 22vh;        /* spacing under fixed top overlay area */
      --dice: 76px;        /* dice size */
    }

    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: 'Cormorant Garamond', serif;
      overflow-x: hidden;
      scroll-behavior: smooth;
      overflow-anchor: none;
    }

    /* Push content below the top overlay area */
    body { padding-top: var(--band); }

    /* Background slideshow (brighter) */
    .background-img {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-height: 70%;
      max-width: 70%;
      opacity: 0.40;
      pointer-events: none;
      z-index: 0;
      filter: contrast(120%) grayscale(60%) brightness(1.05);
      transition: opacity 180ms linear;
    }
    .black-flicker {
      position: fixed;
      inset: 0;
      background: #000;
      opacity: 0;
      transition: opacity 120ms linear;
      z-index: 6;
      pointer-events: none;
    }

    /* Mouse/snake canvas */
    #snake-canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 5;
      pointer-events: none;
    }

    /* Label (hidden after ENTER) */
    .switcher {
      position: fixed;
      top: calc(var(--band) + 1.2rem);
      left: 50%;
      transform: translateX(-50%);
      font-family: Helvetica, Arial, sans-serif;
      font-weight: bold;
      font-size: 2.5rem;
      z-index: 4;
      display: flex; gap: 1rem;
      text-align: left;
      transition: opacity .25s ease;
    }
    .switcher.is-hidden { opacity: 0; pointer-events: none; }
    .planned-word { display: flex; flex-direction: column; align-items: flex-start; line-height: 1.1; }
    .anti-word { visibility: hidden; font-size: 4.5rem; opacity: 0; color: white; transition: opacity .3s, color .3s; }
    .anti-word.visible-white { visibility: visible; opacity: 1; color: white; }
    .anti-word.visible-red   { visibility: visible; opacity: 1; color: red; }

    /* Dice (two) â€” increased spacing */
    .dice {
      position: fixed;
      top: calc(var(--band) + 3rem); /* first die */
      left: 8vw;
      width: var(--dice);
      height: var(--dice);
      perspective: 600px;
      z-index: 7;
      filter: drop-shadow(0 10px 20px rgba(0,0,0,.45)) drop-shadow(0 0 18px rgba(255,255,255,.25));
    }
    .dice2 { top: calc(var(--band) + 12.5rem); } /* << more gap between dice */

    .dice .cube {
      position: relative; width: 100%; height: 100%;
      transform-style: preserve-3d;
      transition: transform 900ms cubic-bezier(.2,.8,.2,1);
      cursor: pointer;
    }
    .dice .face {
      position: absolute; inset: 0;
      display: grid; grid-template: repeat(3,1fr) / repeat(3,1fr); place-items: center;
      background: linear-gradient(145deg, #ffffff, #e7e7e7);
      border-radius: 12px;
      box-shadow: inset 0 0 30px rgba(255,255,255,0.35), inset 0 0 6px rgba(0,0,0,0.15);
    }
    /* BLACK pips */
    .dice .pip{
      width: calc(var(--dice) * 0.16);
      height: calc(var(--dice) * 0.16);
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #000 0 45%, #333 46% 100%);
      box-shadow: 0 1px 0 rgba(255,255,255,.3), inset 0 1px 2px rgba(255,255,255,.25);
    }
    /* faces in 3D */
    .dice .f1 { transform: translateZ(calc(var(--dice)/2)); }
    .dice .f2 { transform: rotateY(180deg) translateZ(calc(var(--dice)/2)); }
    .dice .f3 { transform: rotateY(90deg) translateZ(calc(var(--dice)/2)); }
    .dice .f4 { transform: rotateY(-90deg) translateZ(calc(var(--dice)/2)); }
    .dice .f5 { transform: rotateX(90deg) translateZ(calc(var(--dice)/2)); }
    .dice .f6 { transform: rotateX(-90deg) translateZ(calc(var(--dice)/2)); }

/* Gimbal holds the static tilt; cube only rotates to faces */
.dice .gimbal{
  width:100%; height:100%;
  transform-style: preserve-3d;
  transform: rotateX(-16deg) rotateY(22deg) rotateZ(-2deg);
  will-change: transform;
}

/* Make rotations reliable across Safari/WebKit */
.dice, .dice .cube, .dice .face {
  transform-style: preserve-3d;
}
.dice .cube{
  transition: transform 900ms cubic-bezier(.2,.8,.2,1);
  will-change: transform;
  transform: translateZ(0);          /* GPU kick */
}
.dice .face{
  backface-visibility: hidden;       /* avoid bleed-through */
  transform: translateZ(0);
}


    /* Faster red overlay for doubles */
    .combo-overlay{
      position: fixed; inset: 0;
      background: #c40000;
      display: flex; align-items: center; justify-content: center;
      opacity: 0; transition: opacity .08s ease; /* faster than before */
      z-index: 9999; pointer-events: none;
    }
    .combo-overlay.show{ opacity: 1; }
    .combo-overlay .big{
      font-family: Helvetica, Arial, sans-serif;
      font-weight: 900;
      font-size: clamp(6rem, 22vw, 28rem);
      color: #fff;
      letter-spacing: .08em;
      text-shadow: 0 0 24px rgba(255,255,255,.35);
    }

    /* Hero + content */
    .hero { min-height: calc(100vh - var(--band)); display: grid; place-items: center; position: relative; z-index: 3; }
    .hero-inner { display: grid; place-items: center; }
    .text-flicker { font-family: 'Cinzel', serif; font-size: 5rem; text-align: center; animation: flicker 1s infinite; text-shadow: 0 0 10px white, 0 0 20px white; }
    @keyframes flicker { 0%,19%,21%,23%,25%,54%,56%,100%{opacity:1} 20%,24%,55%{opacity:.4} }
    #enter-btn { margin-top: 2rem; font: inherit; font-size: 1.2rem; background: none; color: #fff; border: 1px solid #fff; padding: .5rem 1.5rem; cursor: pointer; }
    #enter-btn:hover { background: #fff; color: #000; }

    .content { font-size: 1.7rem; min-height: 100vh; display: flex; justify-content: center; align-items: center; z-index: 2; position: relative; opacity: 0; transform: translateY(50px); transition: all 1.2s ease; padding: 0 10vw; text-align: left; background: #000; }
    .content.visible { opacity: 1; transform: translateY(0); }
    .text-block { max-width: 640px; }
    .text-block p { margin: 0 0 1rem 0; line-height: 1.5; }

    @media (max-width: 1024px) { .dice { left: 4vw; transform: scale(.9); } }
    @media (max-width: 820px)  { .dice { display: none; } }
  </style>
</head>
<body>
  <!-- Background slideshow -->
  <img src="images.jpeg" alt="Background" class="background-img" id="bg-img">
  <div class="black-flicker" id="black-fx"></div>

  <!-- Snake layer -->
  <canvas id="snake-canvas"></canvas>

  <!-- DICE (two) -->
  <div class="dice dice1">
  <div class="gimbal">
    <div class="cube" id="cube1">
      <div class="face f1"><span class="pip" style="grid-area:2/2;"></span></div>
      <div class="face f2"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      <div class="face f3"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      <div class="face f4"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      <div class="face f5"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      <div class="face f6"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/1;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/3;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    </div>
</div>
  </div>

  <div class="dice dice2">
  <div class="gimbal">
    <div class="cube" id="cube2">
      <div class="face f1"><span class="pip" style="grid-area:2/2;"></span></div>
      <div class="face f2"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      <div class="face f3"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      <div class="face f4"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      <div class="face f5"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      <div class="face f6"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/1;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/3;"></span><span class="pip" style="grid-area:3/3;"></span></div>
    </div>
</div>
  </div>

  <!-- Red combo overlay -->
  <div class="combo-overlay" id="combo-overlay">
    <div class="big" id="combo-text"></div>
  </div>

  <!-- Label (fades out after ENTER) -->
  <div class="switcher" id="switcher">
    <span class="anti-word" id="anti-text">ANTI-</span>
    <div class="planned-word">
      <span class="line">PLANNED</span>
      <span class="line">ECONOMY</span>
    </div>
  </div>

  <!-- Hero -->
  <section class="hero">
    <div class="hero-inner">
      <div class="text-flicker" id="title">ELSIE CORP.</div>
      <button id="enter-btn">ENTER</button>
    </div>
  </section>

  <!-- Content -->
  <section class="content" id="reveal">
    <div class="text-block">
      <p><strong>ELSIE CORP</strong> is a perfume salon.</p>
      <p>We work with artists, theorists, funders, and institutions to shape forces, not products.</p>
      <p>Our primary goal is consensual abductive teamwork. Here, we are teaching a course on hyperadaptive identities.</p>
    </div>
  </section>

  <script>
    /* Start at top */
    try { if ('scrollRestoration' in history) history.scrollRestoration = 'manual'; } catch(e){}
    window.addEventListener('load', () => window.scrollTo(0, 0));

    /* UI: ENTER + reveal */
    const enterBtn  = document.getElementById('enter-btn');
    const title     = document.getElementById('title');
    const reveal    = document.getElementById('reveal');
    const antiText  = document.getElementById('anti-text');
    const switcher  = document.getElementById('switcher');

    enterBtn.addEventListener('click', () => {
      title.style.animation = 'none';
      title.style.opacity = '1';
      enterBtn.style.display = 'none';
      switcher.classList.add('is-hidden');
      window.scrollTo({ top: reveal.offsetTop, behavior: 'smooth' });
    });

    window.addEventListener('scroll', () => {
      const rect = reveal.getBoundingClientRect();
      if (rect.top < window.innerHeight) {
        reveal.classList.add('visible');
        switcher.classList.add('is-hidden');
      }
    });

    function complexFlickerAnti() {
      antiText.className = 'anti-word visible-white';
      setTimeout(() => {
        antiText.className = 'anti-word';
        setTimeout(() => {
          antiText.className = 'anti-word visible-red';
          setTimeout(() => {
            antiText.className = 'anti-word';
            setTimeout(() => {
              antiText.className = 'anti-word visible-white';
              setTimeout(() => { antiText.className = 'anti-word'; }, 200);
            }, 200);
          }, 120);
        }, 120);
      }, 120);
    }
    (function loopAntiFlicker() {
      const interval = Math.floor(Math.random() * 10000) + 5000;
      setTimeout(() => { complexFlickerAnti(); loopAntiFlicker(); }, interval);
    })();

    /* Slideshow with black flicker (4s) */
    const BG = document.getElementById('bg-img');
    const FX = document.getElementById('black-fx');

    const IMAGES = [
      'images.jpeg',
      '01.png','02.png','02.jpg','03.png','03.jpg',
      '04.jpg','05.jpg','06.jpg','07.jpg','08.jpg',
      '09.jpg','010.jpg','011.jpg','012.jpg','013.jpg'
    ];

    const SHOW_MS = 4000, FLICK_MS = 120;
    IMAGES.forEach(src => { const i = new Image(); i.src = src; });

    let idx = 1;
    setInterval(() => {
      FX.style.opacity = '1';
      setTimeout(() => { BG.src = IMAGES[idx % IMAGES.length]; idx++; FX.style.opacity = '0'; }, FLICK_MS);
    }, SHOW_MS);

    /* --- TWO DICE: roll every 8s; flash red on doubles --- */
const cube1 = document.getElementById('cube1');
const cube2 = document.getElementById('cube2');

const POSES = [
  'rotateX(0deg) rotateY(0deg)',       // 1
  'rotateX(0deg) rotateY(180deg)',     // 2
  'rotateX(0deg) rotateY(-90deg)',     // 3
  'rotateX(0deg) rotateY(90deg)',      // 4
  'rotateX(-90deg) rotateY(0deg)',     // 5
  'rotateX(90deg) rotateY(0deg)'       // 6
];

let faces = [0, 0]; // indices 0..5 (== 1..6)

function setFace(cube, idx){ cube.style.transform = POSES[idx]; }
function rollDie(i, cube){
  let n; do { n = (Math.random() * 6) | 0; } while (n === faces[i]);
  faces[i] = n; setFace(cube, n);
}

function flashIfDouble(){
  if (faces[0] === faces[1]) {
    const overlay = document.getElementById('combo-overlay');
    const text = document.getElementById('combo-text');
    const v = faces[0] + 1;
    text.textContent = `${v}   ${v}`;
    overlay.classList.add('show');
    setTimeout(() => overlay.classList.remove('show'), 2000);
  }
}

// initial poses
setFace(cube1, faces[0]); setFace(cube2, faces[1]);

// roll both every 8s (slightly staggered)
setInterval(() => {
  rollDie(0, cube1);
  setTimeout(() => { rollDie(1, cube2); flashIfDouble(); }, 200);
}, 8000);


    /* SNAKE: start as a rectangle around the image, then gravitate to mouse on die click */
    const cvs = document.getElementById('snake-canvas');
    const ctx = cvs.getContext('2d');

    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      cvs.width  = Math.floor(window.innerWidth  * dpr);
      cvs.height = Math.floor(window.innerHeight * dpr);
      cvs.style.width  = window.innerWidth + 'px';
      cvs.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      computeFrame();                 // recompute frame on resize
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    BG.addEventListener('load', computeFrame); // recompute if image aspect changes

    const TILE  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--px'), 10);
    const TAIL  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--trail-steps'), 10);

    // Frame computed from the displayed image bounds (+ margin)
    const MARGIN_FRAME = TILE * 1.5;  // << frame distance from the image
    let frame = { left: 80, top: 80, right: window.innerWidth-80, bottom: window.innerHeight-80 };

    function snap(v){ return Math.round(v / TILE) * TILE; }

    function computeFrame(){
      const r = BG.getBoundingClientRect();
      // expand by margin and snap to grid
      frame.left   = snap(Math.max(0, r.left   - MARGIN_FRAME));
      frame.top    = snap(Math.max(0, r.top    - MARGIN_FRAME));
      frame.right  = snap(Math.min(window.innerWidth,  r.right  + MARGIN_FRAME));
      frame.bottom = snap(Math.min(window.innerHeight, r.bottom + MARGIN_FRAME));

      // initialize snake to top-left of the frame on first call / if in rect mode
      if (mode === 'rect') {
        head.x = frame.left;
        head.y = frame.top;
        dir = { x: TILE, y: 0 };
        rectEdge = 0;
      }
    }

    // Snake state
    let head = { x: frame.left, y: frame.top };
    let dir  = { x: TILE, y: 0 };
    let trail = [];
    let lastStep = 0;

    // modes: 'rect' (perimeter) -> 'grav' (mouse gravitation)
    let mode = 'rect';
    let rectEdge = 0;                      // 0 top, 1 right, 2 bottom, 3 left
    const RECT_STEP_MS = 70;               // rectangle speed
    const GRAV_STEP_MS = 80;               // gravitate speed (slower)
    let gravStrength = 0;                  // grows after click
    let target = { x: window.innerWidth/2, y: window.innerHeight/2 };
    window.addEventListener('mousemove', (e) => { target.x = e.clientX; target.y = e.clientY; }, { passive: true });

    // clicking either die switches to gravitation
    [cube1, cube2].forEach(c => c.addEventListener('click', (e) => {
      e.stopPropagation();
      mode = 'grav';
      gravStrength = 0; // start gentle, then ramp
    }));

    function step(now){
      requestAnimationFrame(step);
      const ms = (mode === 'rect') ? RECT_STEP_MS : GRAV_STEP_MS;
      if (now - lastStep < ms) return;
      lastStep = now;

      if (mode === 'rect') {
        // move along the frame rectangle, clockwise
        let nx = head.x + dir.x;
        let ny = head.y + dir.y;

        if (rectEdge === 0 && nx >= frame.right) { nx = frame.right; dir = {x:0, y:TILE}; rectEdge = 1; }
        else if (rectEdge === 1 && ny >= frame.bottom){ ny = frame.bottom; dir = {x:-TILE, y:0}; rectEdge = 2; }
        else if (rectEdge === 2 && nx <= frame.left) { nx = frame.left;  dir = {x:0, y:-TILE}; rectEdge = 3; }
        else if (rectEdge === 3 && ny <= frame.top)  { ny = frame.top;   dir = {x:TILE, y:0}; rectEdge = 0; }

        head = { x: nx, y: ny };

      } else {
        // GRAVITATE toward mouse in Manhattan steps (snake vibe)
        gravStrength = Math.min(1, gravStrength + 0.06); // ramp in
        const dx = target.x - head.x, dy = target.y - head.y;

        let stepX = Math.abs(dx) > TILE/2;
        let stepY = Math.abs(dy) > TILE/2;

        // prefer the dominant axis, but soften with strength
        if (stepX && (!stepY || Math.abs(dx) > Math.abs(dy) * (1 - 0.4*gravStrength))) {
          dir = { x: Math.sign(dx) * TILE, y: 0 };
        } else if (stepY) {
          dir = { x: 0, y: Math.sign(dy) * TILE };
        } else {
          dir = { x: 0, y: 0 };
        }

        head = {
          x: Math.max(TILE/2, Math.min(window.innerWidth  - TILE/2, head.x + dir.x)),
          y: Math.max(TILE/2, Math.min(window.innerHeight - TILE/2, head.y + dir.y))
        };
      }

      // trail buffer
      trail.unshift({ x: head.x, y: head.y });
      if (trail.length > TAIL) trail.pop();

      // draw
      ctx.clearRect(0, 0, cvs.width, cvs.height);

      // glow
      ctx.shadowColor = 'rgba(255,255,255,1)';
      ctx.shadowBlur = 20;

      // head
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(head.x, head.y, TILE * 0.8, 0, Math.PI * 2);
      ctx.fill();

      // body squares with fade (grid-snapped)
      for (let i = 1; i < trail.length; i++) {
        const t = i / trail.length;
        const alpha = Math.max(0, 1 - t * 1.05);
        if (alpha <= 0) continue;

        ctx.globalAlpha = alpha;

        const gx = Math.round(trail[i].x / TILE) * TILE;
        const gy = Math.round(trail[i].y / TILE) * TILE;

        ctx.fillStyle = '#fff';
        ctx.fillRect(gx - TILE/2, gy - TILE/2, TILE, TILE);

        // subtle inner pixel
        ctx.globalAlpha = alpha * 0.35;
        const p = TILE / 4;
        ctx.fillRect(gx - TILE/2 + p, gy - TILE/2 + p, TILE - 2*p, TILE - 2*p);
      }

      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }
    requestAnimationFrame(step);

    // initial frame positioning
    computeFrame();
  </script>
</body>
</html>
