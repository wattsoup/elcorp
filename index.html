<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ELSIE INC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@600&family=Cinzel:wght@700&display=swap" rel="stylesheet">

  <style>
    :root{
      --px: 14;            /* snake tile size */
      --trail-steps: 560;  /* long tail so it reads like a frame */
      --band: 16vh;        /* spacing under top band */
      --dice: 76px;        /* dice size */
    }

    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: 'Cormorant Garamond', serif;
      overflow-x: hidden;
      scroll-behavior: smooth;
      overflow-anchor: none;
    }

    /* Push content below the top overlay area */
    body { padding-top: var(--band); }

    /* Background slideshow */
    .background-img {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-height: 70vh;
      max-width: 70vw;
      width: auto;
      height: auto;
      opacity: 0.40;
      pointer-events: none;
      z-index: 0;
      filter: contrast(120%) grayscale(60%) brightness(1.05);
      transition: opacity 180ms linear;
    }
    .black-flicker {
      position: fixed;
      inset: 0;
      background: #000;
      opacity: 0;
      transition: opacity 120ms linear;
      z-index: 6;
      pointer-events: none;
    }

    /* Text Ring/Spiral overlay (new) */
    #pe-ring{
      position: fixed;
      inset: 0;
      z-index: 9;          /* above image, below dice/stats/title */
      pointer-events: none;
    }

    /* Snake layer (on top of content) */
    #snake-canvas{
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 8;     /* above image, below ring/dice/stats */
      pointer-events: none;
      opacity: 1;
    }

    /* LEFT: Dice (two) */
    .dice {
      position: fixed;
      top: calc(var(--band) + 2.6rem);
      left: 6vw;
      width: var(--dice);
      height: var(--dice);
      perspective: 900px;
      perspective-origin: 50% 50%;
      z-index: 12;
      filter: drop-shadow(0 10px 20px rgba(0,0,0,.45)) drop-shadow(0 0 18px rgba(255,255,255,.18));
    }
    .dice2 { top: calc(var(--band) + 13.3rem); left: 9vw; }

    .dice .gimbal{
      width:100%; height:100%;
      transform-style: preserve-3d;
      transform-origin: 50% 50%;
      transform: rotateX(-10deg) rotateY(24deg) rotateZ(0deg);
      animation: wobble3d 6s ease-in-out infinite;
      will-change: transform;
    }
    @keyframes wobble3d{
      0%   { transform: rotateX(-10deg) rotateY(24deg) rotateZ(0deg); }
      50%  { transform: rotateX(-6deg)  rotateY(28deg) rotateZ(0deg); }
      100% { transform: rotateX(-10deg) rotateY(24deg) rotateZ(0deg); }
    }
    .dice, .dice .cube, .dice .face { transform-style: preserve-3d; }
    .dice .cube{
      position: relative; width: 100%; height: 100%;
      transition: transform 900ms cubic-bezier(.2,.8,.2,1);
      will-change: transform;
      transform: translateZ(0);
      cursor: pointer;
    }
    .dice .face{
      position: absolute; inset: 0;
      display: grid; grid-template: repeat(3,1fr) / repeat(3,1fr); place-items: center;
      background:
        radial-gradient(120% 120% at 30% 25%, rgba(255,255,255,.92), rgba(235,235,235,.9) 60%, rgba(215,215,215,.85) 100%);
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.08);
      box-shadow:
        inset 0 0 30px rgba(255,255,255,0.35),
        inset 0 0 8px rgba(0,0,0,0.15);
      backface-visibility: hidden;
      transform: translateZ(0);
    }
    .dice .pip{
      width: calc(var(--dice) * 0.16);
      height: calc(var(--dice) * 0.16);
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #000 0 45%, #333 46% 100%);
      box-shadow: 0 1px 0 rgba(255,255,255,.3), inset 0 1px 2px rgba(255,255,255,.25);
    }
    .dice .f1 { transform: translateZ(calc(var(--dice)/2)); }
    .dice .f2 { transform: rotateY(180deg) translateZ(calc(var(--dice)/2)); }
    .dice .f3 { transform: rotateY(90deg) translateZ(calc(var(--dice)/2)); }
    .dice .f4 { transform: rotateY(-90deg) translateZ(calc(var(--dice)/2)); }
    .dice .f5 { transform: rotateX(90deg) translateZ(calc(var(--dice)/2)); }
    .dice .f6 { transform: rotateX(-90deg) translateZ(calc(var(--dice)/2)); }

    /* RIGHT: Stats */
    .stats{
      position: fixed;
      right: 6vw;
      top: calc(var(--band) - 0.4rem);
      text-align: right;
      z-index: 14;
      user-select: none;
    }
    .stats .label{
      font-family: Helvetica, Arial, sans-serif;
      font-weight: 800;
      letter-spacing: .14em;
      font-size: .92rem;
      opacity: .9;
    }
    .stats .basket-line{
      margin-top: .4rem;
      font-family: Helvetica, Arial, sans-serif;
      letter-spacing: .14em;
      font-weight: 800;
      font-size: 1.0rem;
      opacity: .95;
    }
    .stats .basket-num{
      display: block;
      margin-top: .35rem;
      font-family: 'Cinzel', serif;
      font-weight: 700;
      font-size: clamp(1.3rem, 3.2vw, 2.1rem);
      text-shadow: 0 0 14px rgba(255,255,255,.35), 0 0 26px rgba(255,255,255,.18);
    }

    /* Countdown lower-right (roughly image bottom) */
    .countdown-box{
      position: fixed;
      right: 6vw;
      top: calc(50vh + 30vh); /* ≈ bottom of 70vh image */
      transform: translateY(-50%);
      text-align: right;
      z-index: 14;
      user-select: none;
    }
    .countdown-box .digits{
      font-family: Helvetica, Arial, sans-serif;
      font-weight: 900;
      font-size: clamp(1.8rem, 4.2vw, 2.8rem);
      letter-spacing: .04em;
      text-shadow: 0 0 14px rgba(255,255,255,.35), 0 0 26px rgba(255,255,255,.18);
      font-variant-numeric: tabular-nums lining-nums;
      -moz-font-feature-settings: "tnum" 1, "lnum" 1;
      -webkit-font-feature-settings: "tnum" 1, "lnum" 1;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }

    /* One-off effects ONLY when a double happens */
    .match-bounce { animation: matchBounce .25s ease-out; }
    @keyframes matchBounce {
      0%   { transform: translateY(0) scale(1); }
      40%  { transform: translateY(-1px) scale(1.03); }
      100% { transform: translateY(0) scale(1); }
    }
    .match-flash  { animation: matchFlash .45s ease-out; }
    @keyframes matchFlash {
      0%,100% { color: inherit; text-shadow: 0 0 14px rgba(255,255,255,.25), 0 0 24px rgba(255,255,255,.15); }
      20%,60% { color: #ff3b3b; text-shadow: 0 0 18px rgba(255,0,0,.5), 0 0 28px rgba(255,0,0,.3); }
    }

    /* RED pair overlay */
    .combo-overlay{
      position: fixed; inset: 0;
      background:#c40000;
      display:flex; align-items:center; justify-content:center;
      opacity:0;
      visibility:hidden;
      transition: opacity .08s linear, visibility 0s linear .08s;
      z-index:10000;
      pointer-events:none;
    }
    .combo-overlay.show{
      opacity:1;
      visibility:visible;
      transition: opacity .08s linear;
    }
    .combo-overlay .big{
      font-family: Helvetica, Arial, sans-serif;
      font-weight: 900;
      font-size: clamp(6rem, 22vw, 28rem);
      color: #fff;
      letter-spacing: .08em;
      text-shadow: 0 0 24px rgba(255,255,255,.35);
    }

    .white-flash{
      position: fixed; inset: 0;
      background:#fff;
      opacity:0;
      transition: opacity .06s linear;
      z-index:10002;
      pointer-events:none;
    }
    .white-flash.show{ opacity:1; }

    /* back to the counter (hidden by default) */
    .back-counter{
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 10px);
      left: 6vw;
      z-index: 30;
      display: none;
      background: none; border: 0; padding: 0;
      color:#fff;
      font-family:'Cinzel', serif;
      font-style: italic;
      text-transform: lowercase;
      letter-spacing:.02em;
      cursor:pointer;
      text-shadow: 0 0 8px rgba(255,255,255,.7), 0 0 20px rgba(255,255,255,.35);
      animation: softFlicker 1.2s steps(2,end) infinite;
    }
    @keyframes softFlicker{
      0%,19%,21%,23%,25%,54%,56%,100%{opacity:1}
      20%,24%,55%{opacity:.55}
    }

    /* ===== MILESTONES ===== */
    .milestone{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:#0aa84f;
      opacity:0; visibility:hidden;
      transition:opacity .14s ease;
      z-index:10001;
      pointer-events:none;
      isolation:isolate;
      mix-blend-mode:normal;
    }
    .milestone.show{ opacity:1; visibility:visible; }

    .milestone .inner{
      text-align: center;
      color: #fff;
      line-height: 1.1;
      white-space: pre-line;
      font-family: Helvetica, Arial, sans-serif;
      text-transform: none;
      text-shadow: 0 0 18px rgba(255,255,255,.25);
      padding: 4vmin 6vmin;
    }
    .milestone.red   { background:#d30000; }
    .milestone.green { background:#0aa84f; }
    .milestone.black { background:#000000; }

    /* size presets */
    .ms-huge   { font-weight: 900; font-size: clamp(3.4rem, 12vw, 12rem); }
    .ms-big    { font-weight: 900; font-size: clamp(2.6rem, 10vw, 10rem); }
    .ms-medium { font-weight: 800; font-size: clamp(1.4rem, 4vw, 3rem); }
    .ms-small  { font-weight: 600; font-size: clamp(0.95rem, 2.2vw, 1.3rem); line-height: 1.35; }
    .ms-italic    { font-style: italic; }
    .ms-lowercase { text-transform: lowercase; }

    /* Label (center) – we leave it for now; ring overlay is the new motion layer */
    .switcher {
      position: fixed;
      top: calc(var(--band) + 1.0rem);
      left: 50%;
      transform: translateX(-50%);
      font-family: Helvetica, Arial, sans-serif;
      font-weight: 800;
      font-size: 2.3rem;
      z-index: 10;
      display: flex; gap: 1rem;
      text-align: left;
      transition: opacity .25s ease;
      pointer-events: none;
    }
    .switcher.is-hidden { opacity: 0; }
    .planned-word { display: flex; flex-direction: column; align-items: flex-start; line-height: 1.05; }
    .anti-word { visibility: hidden; font-size: 3.2rem; opacity: 0; color: white; transition: opacity .3s, color .3s; }
    .anti-word.visible-white { visibility: visible; opacity: 1; color: white; }
    .anti-word.visible-red   { visibility: visible; opacity: 1; color: red; }

    /* Hero + content */
    .hero { min-height: calc(100vh - var(--band)); display: grid; place-items: center; position: relative; z-index: 3; }
    .hero-inner { display: grid; place-items: center; }

    /* ELSIE INC. – no auto flicker. JS adds .star-flick on dice rolls */
    .text-flicker {
      font-family: 'Cormorant Garamond', serif;
      font-size: 5rem;
      text-align: center;
      text-shadow: 0 0 8px rgba(255,255,255,0.5), 0 0 18px rgba(255,255,255,0.25);
    }
    .star-flick { animation: flickerStars 0.9s steps(1,end); }
    @keyframes flickerStars{
      0%,7%,11%,19%,23%,31%,49%,61%,73%,100% { opacity:1; text-shadow:0 0 8px rgba(255,255,255,.6), 0 0 20px rgba(255,255,255,.4); }
      8%,20%,50%,62%                                   { opacity:.55; text-shadow:0 0 4px rgba(255,255,255,.25); }
      12%,33%,70%                                      { opacity:.2;  text-shadow:none; }
    }

    #enter-btn { margin-top: 2rem; font: inherit; font-size: 1.2rem; background: none; color: #fff; border: 1px solid #fff; padding: .5rem 1.5rem; cursor: pointer; }
    #enter-btn:hover { background: #fff; color: #000; }

    .content { font-size: 1.7rem; min-height: 100vh; display: flex; justify-content: center; align-items: center; z-index: 2; position: relative; opacity: 0; transform: translateY(50px); transition: all 1.2s ease; padding: 0 10vw; text-align: left; background: #000; }
    .content.visible { opacity: 1; transform: translateY(0); }

    .text-block { position: relative; max-width: 640px; margin: 0 auto; }
    .text-block p { margin: 0 0 1rem 0; line-height: 1.5; }

    /* JOIN badge under text section */
    .join-badge{
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: calc(100% + 1rem);
      padding: .3rem 1.2rem;
      border: 1px solid #fff;
      font-family: 'Cinzel', serif;
      letter-spacing: .08em;
      opacity: 0;
      transition: opacity .18s ease;
      pointer-events: none;
    }
    .join-badge.show{ opacity: 1; }

    /* ===== PHONE REFINEMENTS ===== */
    @media (max-width: 820px){

      .text-flicker{
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + 4.2rem);
        left: 50%;
        transform: translateX(-50%);
        width: 92vw;
        text-align: center;
        font-size: clamp(3.2rem, 12vw, 4.6rem);
        line-height: 1;
        white-space: nowrap;
        z-index: 12;
      }

      .switcher{
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + 7.8rem);
        left: 50%;
        transform: translateX(-50%);
        width: 92vw;
        text-align: center;
        font-size: clamp(1.15rem, 5.8vw, 1.9rem);
        white-space: nowrap;
        gap: 0;
        z-index: 9;
      }
      .switcher .anti-word{
        font-size: inherit;
        margin-right: .1rem;
        position: relative;
        top: -0.06em;
      }
      .planned-word{ flex-direction: row; gap: .45rem; }
      .planned-word .line{ display:inline-block; }

      :root{ --dice: 76px; }
      .dice, .dice2{ left: 50%; transform: translateX(-50%); z-index: 12; }
      .dice  { top: 36vh; margin-left: calc(-0.70 * var(--dice)); }
      .dice2 { top: 44vh; margin-left: calc( 0.50 * var(--dice)); }

      #enter-btn{
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        top: 58vh;
        z-index: 15;
        pointer-events: auto;
      }

      .countdown-box{
        position: fixed; left: 5vw; right: auto;
        bottom: 8.6vh; top: auto; transform: none; text-align: left;
      }
      .countdown-box .digits{
        font-size: clamp(1.9rem, 8.2vw, 2.6rem);
        line-height: 1;
        font-variant-numeric: tabular-nums lining-nums;
        -moz-font-feature-settings: "tnum" 1, "lnum" 1;
        -webkit-font-feature-settings: "tnum" 1, "lnum" 1;
        font-feature-settings: "tnum" 1, "lnum" 1;
        transform: translateY(0.06em);
      }

      .stats{
        position: fixed; right: 5vw; left: auto;
        bottom: 8.6vh; top: auto; text-align: right;
        display: flex; flex-direction: column; align-items: flex-end;
      }
      .stats .basket-num{ order: 0; font-size: clamp(1.9rem, 8.2vw, 2.6rem); line-height: 1; }
      .stats .label     { order: 1; font-size: .95rem;  margin-top: .25rem; }
      .stats .basket-line{order: 2; font-size: 1.05rem; margin-top: .1rem;}

      body.reading #bg-img{ opacity: 0 !important; }
      body.reading #snake-canvas{ display: none !important; }
      body.reading .text-flicker,
      body.reading .switcher,
      body.reading .countdown-box,
      body.reading .stats{ display: none !important; }
      body.reading #enter-btn{ display: none !important; }

      body.reading .dice, body.reading .dice2{
        opacity: .26;
        z-index: 1;
        filter: drop-shadow(0 6px 12px rgba(0,0,0,.35));
        pointer-events: auto;
      }
      body.reading .content{ background: transparent !important; }

      body.reading .dice,
      body.reading .dice2{
        opacity: .34;
        filter: drop-shadow(0 6px 12px rgba(0,0,0,.35));
      }

      .content{ font-size: clamp(1.2rem, 5.4vw, 1.5rem); }
      .back-counter{ font-size: clamp(1.05rem, 4.8vw, 1.6rem); }
      body.reading .back-counter{ display: block; }
    }
  </style>
</head>
<body>
  <!-- Background slideshow -->
  <img src="images.jpeg" alt="Background" class="background-img" id="bg-img">
  <div class="black-flicker" id="black-fx"></div>

  <!-- NEW: Text Ring/Spiral overlay -->
  <canvas id="pe-ring" aria-hidden="true"></canvas>

  <!-- Snake layer -->
  <canvas id="snake-canvas"></canvas>

  <!-- LEFT: DICE (two) -->
  <div class="dice dice1">
    <div class="gimbal">
      <div class="cube" id="cube1">
        <div class="face f1"><span class="pip" style="grid-area:2/2;"></span></div>
        <div class="face f2"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f3"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f4"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f5"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f6"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/1;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/3;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      </div>
    </div>
  </div>

  <div class="dice dice2">
    <div class="gimbal">
      <div class="cube" id="cube2">
        <div class="face f1"><span class="pip" style="grid-area:2/2;"></span></div>
        <div class="face f2"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f3"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f4"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f5"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/2;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:3/3;"></span></div>
        <div class="face f6"><span class="pip" style="grid-area:1/1;"></span><span class="pip" style="grid-area:2/1;"></span><span class="pip" style="grid-area:3/1;"></span><span class="pip" style="grid-area:1/3;"></span><span class="pip" style="grid-area:2/3;"></span><span class="pip" style="grid-area:3/3;"></span></div>
      </div>
    </div>
  </div>

  <!-- RIGHT: Stats (top-right) -->
  <aside class="stats">
    <div class="label">PERFUMES</div>
    <div class="basket-line">IN YOUR BASKET:</div>
    <span id="basket-num" class="basket-num">0</span>
  </aside>

  <!-- RIGHT: Countdown (lower-right) -->
  <aside class="countdown-box">
    <div id="countdown" class="digits">00:00:00</div>
  </aside>

  <!-- Red combo overlay -->
  <div class="combo-overlay" id="combo-overlay">
    <div class="big" id="combo-text"></div>
  </div>

  <div id="white-flash" class="white-flash"></div>
  
  <!-- Milestone overlay (big messages on color backgrounds) -->
  <div id="milestone" class="milestone">
    <div id="milestone-inner" class="inner ms-big"></div>
  </div>

  <button id="back-btn" class="back-counter">back to the counter</button>

  <!-- Center label (kept) -->
  <div class="switcher" id="switcher">
    <span class="anti-word" id="anti-text">ANTI-</span>
    <div class="planned-word">
      <span class="line">PLANNED</span>
      <span class="line">ECONOMY</span>
    </div>
  </div>

  <!-- Hero -->
  <section class="hero">
    <div class="hero-inner">
      <div class="text-flicker" id="title">ЕLSIE INC.</div>
      <button id="enter-btn">ENTER</button>
    </div>
  </section>

  <!-- Content -->
  <section class="content" id="reveal">
    <div class="text-block">
      <p><strong>ELSIE INC</strong> is a perfume salon.</p>
      <p>We work on the <em>Playground for the Muddle of History</em> with angel investors, soft speculators, and practitioners of the <span style="
        display: inline-block; transform: scaleX(-1); font-style: italic;">transcendental turn</span> <span style="display:inline-block; transform: scaleX(-1);">...</span></p>
      <p>Our primary goal is consensual abductive teamwork. Here, we are teaching a course on hyperadaptive identities.</p>
      <div id="join-badge" class="join-badge">JOIN</div>
    </div>
  </section>

  <!-- ========== JS ========== -->
  <script>
    /* Start at top */
    try { if ('scrollRestoration' in history) history.scrollRestoration = 'manual'; } catch(e){}
    window.addEventListener('load', () => window.scrollTo(0, 0));

    /* UI: ENTER + reveal */
    const enterBtn  = document.getElementById('enter-btn');
    const title     = document.getElementById('title');
    const reveal    = document.getElementById('reveal');
    const antiText  = document.getElementById('anti-text');
    const switcher  = document.getElementById('switcher');

    enterBtn.addEventListener('click', () => {
      if (window.matchMedia('(max-width: 820px)').matches) {
        document.body.classList.add('reading');
      }
      title.style.opacity = '1';
      enterBtn.style.display = 'none';
      switcher.classList.add('is-hidden');
      window.scrollTo({ top: reveal.offsetTop, behavior: 'smooth' });
    });

    const backBtn = document.getElementById('back-btn');
    if (backBtn) {
      backBtn.addEventListener('click', () => {
        document.body.classList.remove('reading');
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    }

    let contentVisible = false;
    window.addEventListener('scroll', () => {
      const rect = reveal.getBoundingClientRect();
      if (rect.top < window.innerHeight) {
        reveal.classList.add('visible');
        switcher.classList.add('is-hidden');
        contentVisible = true;
      }
    });

    /* ---------- Slideshow (4s) ---------- */
    const BG = document.getElementById('bg-img');
    const FX = document.getElementById('black-fx');

    const IMAGES = [
      'images.jpeg',
      '01.png','02.png','02.jpg','03.png','03.jpg',
      '04.jpg','05.jpg','06.jpg','07.jpg','08.jpg',
      '09.jpg','010.jpg','011.jpg','012.jpg','013.jpg'
    ];
    IMAGES.forEach(src => { const i = new Image(); i.src = src; });

    const SHOW_MS = 4000, FLICK_MS = 120;
    let idx = 1;

    /* ---------- Dice ---------- */
    const cube1 = document.getElementById('cube1');
    const cube2 = document.getElementById('cube2');

    const POSES = [
      'rotateX(0deg) rotateY(0deg)',       // 1
      'rotateX(0deg) rotateY(180deg)',     // 2
      'rotateX(0deg) rotateY(-90deg)',     // 3
      'rotateX(0deg) rotateY(90deg)',      // 4
      'rotateX(-90deg) rotateY(0deg)',     // 5
      'rotateX(90deg) rotateY(0deg)'       // 6
    ];

    let faces = [0, 0];
    function setFace(c, idx){ c.style.transform = POSES[idx]; }
    function rollDie(i, c){
      let n; do { n = (Math.random() * 6) | 0; } while (n === faces[i]);
      faces[i] = n; setFace(c, n);
    }
    setFace(cube1, faces[0]); setFace(cube2, faces[1]);

    /* ---------- Stats (basket + countdown) ---------- */
    const basketEl    = document.getElementById('basket-num');
    const countdownEl = document.getElementById('countdown');
    const joinBadge   = document.getElementById('join-badge');

    let rollCount = 0;

    function flashOnce(el){
      el.classList.remove('match-flash','match-bounce');
      void el.offsetWidth;
      el.classList.add('match-flash','match-bounce');
      setTimeout(() => el.classList.remove('match-flash','match-bounce'), 500);
    }

    let basket = 0;
    let cdTarget = new Date(Date.now() + 3600 * 1000);

    function setRandomCountdown(){
      const hrs = Math.floor(Math.random()*7) + 1;
      const mins = Math.floor(Math.random()*60);
      const secs = Math.floor(Math.random()*50)+10;
      cdTarget = new Date(Date.now() + (hrs*3600 + mins*60 + secs)*1000);
      countdownEl.textContent = [hrs,mins,secs].map(v=>String(v).padStart(2,'0')).join(':');
    }
    function tickCountdown(){
      const now = new Date();
      let diff = Math.max(0, Math.floor((cdTarget - now)/1000));
      const h = String(Math.floor(diff/3600)).padStart(2,'0');
      diff %= 3600;
      const m = String(Math.floor(diff/60)).padStart(2,'0');
      const s = String(diff%60).padStart(2,'0');
      countdownEl.textContent = `${h}:${m}:${s}`;
    }
    setInterval(tickCountdown, 1000);
    setRandomCountdown();

    /* ===== ELSIE title flicker synced to rolls ===== */
    function flickerTitleStars(){
      title.classList.remove('star-flick');
      void title.offsetWidth;
      title.classList.add('star-flick');
      setTimeout(()=>title.classList.remove('star-flick'), 950);
    }

    function flashOverlay(val, showMs = 260){
      const overlay = document.getElementById('combo-overlay');
      const text = document.getElementById('combo-text');
      return new Promise(resolve => {
        text.textContent = `${val}   ${val}`;
        overlay.classList.add('show');
        setTimeout(() => {
          const onEnd = (e) => {
            if (e.propertyName === 'opacity') {
              overlay.removeEventListener('transitionend', onEnd);
              resolve();
            }
          };
          overlay.addEventListener('transitionend', onEnd, { once:true });
          overlay.classList.remove('show');
        }, showMs);
      });
    }
    function whiteFlash(ms = 70){
      const wf = document.getElementById('white-flash');
      if (!wf) return Promise.resolve();
      return new Promise(resolve => {
        wf.classList.add('show');
        setTimeout(() => {
          wf.classList.remove('show');
          setTimeout(resolve, 80);
        }, ms);
      });
    }

    /* ===== MILESTONES ===== */
    const milestoneEl = document.getElementById('milestone');
    const milestoneInner = document.getElementById('milestone-inner');

    const MILESTONES = {
      5:  { bg:'#0d8f4a', text:'WAGMI',                         cls:'ms-huge',                 dur:1400 },
      10: { bg:'#c40000', text:'ily\nsometimes',                cls:'ms-huge ms-lowercase',    dur:1500 },
      15: { bg:'#000000', text:'WAGMI\nWAGMI\nWAGMI',           cls:'ms-huge',                 dur:1400 },
      20: { bg:'#c40000', text:'its was all planned\nTHANK YOU FOR PLAYING', cls:'ms-big',    dur:1800 },
      25: { bg:'#0d8f4a', text:`I'm thinking of art as an inversion of apocalypse, art as an inversion of revelation, art as obscuration of, not necessarily truth, maybe that's the thing, because Heidegger is talking about, what is his term that he is using, coming into being, what is his term, but he basically resorts to pre-socraticism, this process of revealing, revealing, yeah, he's talking about revealing via technology, and it's apocalyptic also, he's like also an apocalyptic thinker, Hegelian is also an apocalyptic thinker, but I'm thinking, yeah, like in some parts, art still needs this revelation, because there is things to reveal still, there are things to learn from, but art bubble definitely does not need any revelation, they need something else, but global, like a more globalized, like Normie, you know, Normies need revelation, art hosts don't need revelation, so there should be like a systematic overview of like strategic tasking for a contemporary artist, which is taking into consideration the complex, layered environments that, where some of them require apocalypse, and some of them don't.`,
           cls:'ms-small', dur:6500 },
      30: { bg:'#c40000', text:'They made all the roses transparent. Toss a coin! They put on soundcloud mysticism. They were imposing “DJ BERKLEY” upon us. Toss a coin! GO ON',
           cls:'ms-medium', dur:3200 },
      35: { bg:'#c40000', text:'GO ON',                        cls:'ms-huge',                 dur:1500 },
      40: { bg:'#0d8f4a', text:'A LITTLE MORE',                cls:'ms-huge',                 dur:1500 },
      50: { bg:'#c40000', text:'Redistribution of the..\nsensible-financial',
           cls:'ms-big ms-italic',                              dur:2000 },
      60: { bg:'#7a0000', text:'secret',                        cls:'ms-huge',                 dur:1600 },
      70: { bg:'#000000', text:'sorry. forgive me. forgive me', cls:'ms-big ms-lowercase',     dur:2000 },
    };

    function showMilestone(n){
      const ms = MILESTONES?.[n];
      return new Promise(resolve => {
        if (!ms) return resolve();
        milestoneEl.style.background = ms.bg;
        milestoneInner.className = 'inner ' + ms.cls;
        milestoneInner.textContent = ms.text;
        milestoneEl.classList.add('show');
        setTimeout(() => {
          milestoneEl.classList.remove('show');
          resolve();
        }, ms.dur || 1600);
      });
    }

    async function onDouble(val){
      basket += 1;
      basketEl.textContent = String(basket);
      flashOnce(basketEl);
      flashOnce(countdownEl);
      setRandomCountdown();

      await flashOverlay(val, 260);
      await whiteFlash(70);
      await showMilestone(basket);

      maybeShowJoin();
      // NEW: strobe the ANTI on the ring when doubles hit
      if (window.PE_RING_EDGE) window.PE_RING_EDGE();
    }

    function pulseJoin(){
      if (!contentVisible) return;
      joinBadge.classList.add('show');
      setTimeout(() => joinBadge.classList.remove('show'), 1000);
    }
    function maybeShowJoin(){
      if (!contentVisible) return;
      if (Math.random() < 0.35) pulseJoin();
    }

    function rollBothAndMaybeFlash(){
      rollCount++;
      rollDie(0, cube1);
      setTimeout(() => {
        rollDie(1, cube2);
        // Title twinkle on every roll
        flickerTitleStars();

        if (faces[0] === faces[1]) {
          const val = faces[0] + 1;
          onDouble(val);
        }
        if (rollCount % 2 === 0) pulseJoin();
      }, 0);
    }

    // roll when image changes (every 4s)
    setInterval(() => {
      FX.style.opacity = '1';
      setTimeout(() => {
        BG.src = IMAGES[idx % IMAGES.length];
        idx++;
        rollBothAndMaybeFlash();
        FX.style.opacity = '0';
      }, FLICK_MS);
    }, SHOW_MS);

    // clicking a die also rolls & makes snake gravitate
    document.querySelectorAll('.cube').forEach(c => c.addEventListener('click', () => {
      rollBothAndMaybeFlash();
      mode = 'grav'; gravStrength = 0;
    }));

    /* ===================== TEXT RING / SPIRAL (Canvas) ===================== */
    (() => {
      const cvs = document.getElementById('pe-ring');
      const ctx = cvs.getContext('2d');
      const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      function resize(){
        cvs.width  = Math.floor(innerWidth  * DPR);
        cvs.height = Math.floor(innerHeight * DPR);
        cvs.style.width  = innerWidth  + 'px';
        cvs.style.height = innerHeight + 'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      addEventListener('resize', resize, {passive:true});
      resize();

      // Style
      const TEXT = ' PLANNED ECONOMY ';
      const FONT = 'Helvetica, Arial, sans-serif';
      const BASE = 'rgba(255,255,255,0.95)';
      const GLOW = 'rgba(255,255,255,0.35)';
      const RED  = 'rgba(255,40,40,1)';

      const RING = { radiusFactor: 0.30, speed: 0.35, spacing: 0.96, antiBlink: [80,140] }; // contained in image
      const SPIRAL = { growPct:.10, gravity:1400, scatter:190, holdMs:1200 };

      let MODE = 'ring'; // 'ring' or 'spiral'
      window.PE_RING = {
        startRing(){ MODE='ring'; },
        startSpiral(){ MODE='spiral'; stage='spiralIn'; tStage=0; },
        popNow(){ if (MODE==='spiral') stage='pop'; }
      };
      function pickBlink(){ return Math.round(Math.random()*(RING.antiBlink[1]-RING.antiBlink[0])+RING.antiBlink[0]); }

      // State
      let t0 = performance.now();
      let baseAngle = 0;
      let antiPos = Math.random();
      let nextAntiHop = performance.now() + 900;
      let antiBlinkUntil = 0;
      let stage='ring', tStage=0, particles=[];

      function imgFrame(){
        // use current background image rect as container
        const r = BG.getBoundingClientRect();
        // fallback to a centered square if image not ready
        if (!isFinite(r.left) || r.width<20 || r.height<20){
          const vw = innerWidth, vh = innerHeight;
          const s = Math.round(0.70 * Math.min(vw, vh));
          const L = Math.round((vw-s)/2), T = Math.round((vh-s)/2);
          return {left:L, top:T, right:L+s, bottom:T+s, width:s, height:s};
        }
        return {left:r.left, top:r.top, right:r.right, bottom:r.bottom, width:r.width, height:r.height};
      }

      function buildChars(circumference, fontPx){
        ctx.save();
        ctx.font = `900 ${fontPx}px ${FONT}`;
        const sample = 'PLANNED ECONOMY ';
        const avg = ctx.measureText(sample).width / sample.length;
        const n = Math.max(24, Math.floor(circumference / (avg * RING.spacing)));
        ctx.restore();
        return (TEXT.repeat(40).slice(0,n)).split('');
      }

      function drawRing(cx, cy, r, rot, chars){
        ctx.save();
        const fontPx = Math.max(14, Math.min(42, r * 0.13));
        ctx.font = `900 ${fontPx}px ${FONT}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const step = (2*Math.PI)/chars.length;

        for (let i=0;i<chars.length;i++){
          const theta = rot + i*step;
          const u = i/chars.length;
          const isAnti = Math.abs(u - antiPos) < (step/(2*Math.PI))*3;
          ctx.save();
          ctx.translate(cx + r*Math.cos(theta), cy + r*Math.sin(theta));
          ctx.rotate(theta + Math.PI/2);
          if (isAnti && performance.now() < antiBlinkUntil){
            ctx.fillStyle = RED; ctx.shadowColor = RED; ctx.shadowBlur = 12;
          } else {
            ctx.fillStyle = BASE; ctx.shadowColor = GLOW; ctx.shadowBlur = 8;
          }
          ctx.fillText(chars[i], 0, 0);
          ctx.restore();
        }
        ctx.restore();
      }

      function spawnParticles(cx, cy, r, rot, chars){
        particles.length = 0;
        const step = (2*Math.PI)/chars.length;
        const fontPx = Math.max(14, Math.min(42, r * 0.13));
        for (let i=0;i<chars.length;i++){
          const th = rot + i*step;
          const x = cx + r*Math.cos(th), y = cy + r*Math.sin(th);
          const vx = (Math.random()*2-1)*SPIRAL.scatter;
          const vy = -(Math.random()*0.6+0.5)*SPIRAL.scatter;
          particles.push({ch:chars[i], x, y, vx, vy, rot:(Math.random()*1.6-0.8), a:1, f:fontPx});
        }
      }

      function tick(now){
        const dt = (now - t0)/1000; t0 = now;
        ctx.clearRect(0,0,cvs.width/DPR,cvs.height/DPR);

        // compute contained ring center/radius from image frame
        const fr = imgFrame();
        const cx = fr.left + fr.width/2;
        const cy = fr.top  + fr.height/2;
        const r  = Math.min(fr.width, fr.height) * RING.radiusFactor; // ~30% of image size

        const chars = buildChars(2*Math.PI*r, Math.max(16, r*0.13));

        // rotation & ANTI hop
        baseAngle += 2*Math.PI * RING.speed * dt;
        if (now >= nextAntiHop){
          antiPos = Math.random();
          antiBlinkUntil = now + pickBlink();
          nextAntiHop = now + (900 + Math.random()*1300);
        }

        if (MODE==='ring' || stage==='ring' || stage==='ringHold' || stage==='grow'){
          let rDraw = r;
          if (MODE==='spiral' && stage==='grow'){
            const k = Math.min(1, tStage/700);
            rDraw = r * (1 + SPIRAL.growPct * (1-(1-k)*(1-k)));
          }
          drawRing(cx, cy, rDraw, baseAngle, chars);

          if (MODE==='spiral'){
            tStage += (dt*1000);
            if (stage==='spiralIn'){
              baseAngle += 2*Math.PI * 0.9 * dt;
              if (tStage > 1200){ stage='ringHold'; tStage=0; }
            } else if (stage==='ringHold'){
              if (tStage > SPIRAL.holdMs){ stage='grow'; tStage=0; }
            } else if (stage==='grow'){
              if (tStage > 700){
                stage='pop'; tStage=0;
                spawnParticles(cx, cy, rDraw, baseAngle, chars);
              }
            }
          }
        }

        // POP → FALL
        if (MODE==='spiral' && (stage==='pop' || stage==='fall')){
          stage='fall';
          const g = SPIRAL.gravity;
          const floor = innerHeight - 14;
          particles.forEach(p => {
            p.vy += g*dt;
            p.x  += p.vx*dt;
            p.y  += p.vy*dt;
            p.rot += 0.9*dt;
            if (p.y >= floor){
              p.y = floor;
              p.vy *= -0.35;
              p.vx *= 0.82;
              if (Math.abs(p.vy) < 60){ p.vy=0; p.vx*=0.92; p.a = 0.65; }
            }
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rot);
            ctx.font = `900 ${p.f}px ${FONT}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = GLOW; ctx.shadowBlur = 6;
            ctx.fillStyle = `rgba(255,255,255,${p.a})`;
            ctx.fillText(p.ch, 0, 0);
            ctx.restore();
          });
        }

        requestAnimationFrame(tick);
      }

      // Kick off (ring by default)
      requestAnimationFrame((t)=>{ t0=t; requestAnimationFrame(tick); });

      // Expose an edge-strobe hook for doubles
      window.PE_RING_EDGE = function(){
        antiBlinkUntil = performance.now() + pickBlink();
      };
    })();

    /* ===================== SNAKE ===================== */
    const cvs = document.getElementById('snake-canvas');
    const ctx2 = cvs.getContext('2d');

    function resizeCanvas() {
      cvs.width  = window.innerWidth;
      cvs.height = window.innerHeight;
      ctx2.setTransform(1, 0, 0, 1, 0, 0);
      computeFrame();
    }
    window.addEventListener('resize', resizeCanvas);
    BG.addEventListener('load', computeFrame);
    resizeCanvas();

    const TILE  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--px'), 10);
    const TAIL  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--trail-steps'), 10);
    const MARGIN_FRAME = TILE * 2.2;

    let frame = { left: 80, top: 80, right: window.innerWidth-80, bottom: window.innerHeight-80 };
    function snap(v){ return Math.round(v / TILE) * TILE; }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function computeFrame(){
      const r = BG.getBoundingClientRect();
      let L = r.left   - MARGIN_FRAME;
      let T = r.top    - MARGIN_FRAME;
      let R = r.right  + MARGIN_FRAME;
      let B = r.bottom + MARGIN_FRAME;

      const tooSmall = (R - L) < TILE*12 || (B - T) < TILE*12 || !isFinite(L);
      if (tooSmall) {
        const vw = innerWidth, vh = innerHeight;
        const s  = Math.round(0.70 * Math.min(vw, vh));
        const L0 = Math.round((vw - s) / 2);
        const T0 = Math.round((vh - s) / 2);
        L = L0 - MARGIN_FRAME; T = T0 - MARGIN_FRAME; R = L0 + s + MARGIN_FRAME; B = T0 + s + MARGIN_FRAME;
      }

      frame.left   = snap(clamp(L, 8, innerWidth  - 8));
      frame.top    = snap(clamp(T, 8, innerHeight - 8));
      frame.right  = snap(clamp(R, frame.left+TILE*4, innerWidth  - 8));
      frame.bottom = snap(clamp(B, frame.top +TILE*4, innerHeight - 8));

      if (mode === 'rect') {
        head.x = frame.left;
        head.y = frame.top;
        dir = { x: TILE, y: 0 };
        rectEdge = 0;
      }
    }

    // snake state
    let head = { x: frame.left, y: frame.top };
    let dir  = { x: TILE, y: 0 };
    let trail = [];
    let lastStep = 0;

    let mode = 'rect';           // 'rect' perimeter -> 'grav' (after click)
    let rectEdge = 0;            // 0 top, 1 right, 2 bottom, 3 left
    const RECT_STEP_MS = 56;     // perimeter speed
    const GRAV_STEP_MS = 74;     // gravitate speed
    let gravStrength = 0;
    let target = { x: innerWidth/2, y: innerHeight/2 };
    window.addEventListener('mousemove', e => { target.x = e.clientX; target.y = e.clientY; }, { passive: true });

    function step(now){
      requestAnimationFrame(step);
      const ms = (mode === 'rect') ? RECT_STEP_MS : GRAV_STEP_MS;
      if (now - lastStep < ms) return;
      lastStep = now;

      if (mode === 'rect') {
        let nx = head.x + dir.x, ny = head.y + dir.y;
        if (rectEdge === 0 && nx >= frame.right)      { nx = frame.right;  dir = {x:0, y:TILE};   rectEdge = 1; }
        else if (rectEdge === 1 && ny >= frame.bottom){ ny = frame.bottom; dir = {x:-TILE, y:0}; rectEdge = 2; }
        else if (rectEdge === 2 && nx <= frame.left)  { nx = frame.left;   dir = {x:0, y:-TILE};  rectEdge = 3; }
        else if (rectEdge === 3 && ny <= frame.top)   { ny = frame.top;    dir = {x:TILE, y:0};   rectEdge = 0; }
        head = { x: nx, y: ny };
      } else {
        gravStrength = Math.min(1, gravStrength + 0.06);
        const dx = target.x - head.x, dy = target.y - head.y;
        const preferX = Math.abs(dx) > Math.abs(dy) * (1 - 0.4*gravStrength);
        if (preferX && Math.abs(dx) > TILE/2)      dir = { x: Math.sign(dx)*TILE, y: 0 };
        else if (Math.abs(dy) > TILE/2)            dir = { x: 0, y: Math.sign(dy)*TILE };
        else                                       dir = { x: 0, y: 0 };
        head = {
          x: clamp(head.x + dir.x, TILE/2, innerWidth  - TILE/2),
          y: clamp(head.y + dir.y, TILE/2, innerHeight - TILE/2)
        };
      }

      trail.unshift({ x: head.x, y: head.y });
      if (trail.length > TAIL) trail.pop();

      // draw
      const ctx = ctx2;
      ctx.clearRect(0, 0, cvs.width, cvs.height);

      // glow
      ctx.shadowColor = 'rgba(255,255,255,1)';
      ctx.shadowBlur = 26;

      // head
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(head.x, head.y, TILE * 0.9, 0, Math.PI * 2);
      ctx.fill();

      // body squares with fade (grid-snapped)
      for (let i = 1; i < trail.length; i++) {
        const t = i / trail.length;
        const alpha = Math.max(0, 1 - t * 1.05);
        if (alpha <= 0) continue;

        ctx.globalAlpha = alpha;
        const gx = Math.round(trail[i].x / TILE) * TILE;
        const gy = Math.round(trail[i].y / TILE) * TILE;

        ctx.fillStyle = '#fff';
        ctx.fillRect(gx - TILE/2, gy - TILE/2, TILE, TILE);

        ctx.globalAlpha = alpha * 0.35;
        const p = TILE / 4;
        ctx.fillRect(gx - TILE/2 + p, gy - TILE/2 + p, TILE - 2*p, TILE - 2*p);
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    function primeTrail(len = 28){
      trail.length = 0;
      for (let i = 0; i < len; i++){
        trail.unshift({ x: frame.left - i*TILE, y: frame.top });
      }
    }

    requestAnimationFrame(step);
    computeFrame();
    primeTrail();
  </script>
</body>
</html>
